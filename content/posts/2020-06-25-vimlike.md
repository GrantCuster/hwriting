---
date: 2020-06-25T10:18:20
title: "Vimlike"
---

This [thread](https://twitter.com/helvetica/status/1274450330726645762), by Zach Gage, on how genre conventions serve as interaction shortcuts, got me thinking about how I use Vim conventions in my creative tools at [Constraint Systems](https://constraint.systems).

https://twitter.com/helvetica/status/1274450330726645762:

> 7/ A big part of making games involves working with genre literacy. In game design a key concept is the idea of weight: Every rule you add has a cognitive load on the player, and you must balance the weight of your rules against how meaningful they are to the play experience.

> 8/ An idea might be great, but if it makes the game unwieldy, ditch it. But genre-conventions are different -- they're weightless. They allow for an increased complexity and nuance in games, because they let designers include a huge number of rules without adding any weight.

Almost all of the experiments on Constraint Systems use Vim conventions: at least the `hjkl` characters for movement. One of the big reasons I started the experiments was my fascination with how I felt using Vim in the terminal. The combination of a strict character grid and keyboard controls provide a feeling of stability, and through that calm, that I don't feel in other programs, or using a computer in general.

This was especially in contrast to how I've felt when making gestural interface, or ones that simulate physics. Building those often felt like piling on edge-case handler on top of edge-case handler. If you did it well you could make a pleasing user experience, as long as they stuck to the path you had prepared. If they wanted to go a different direction, or you wanted to take the program in a new direction, you had to deal with that unwieldy tower, either by rearchitecting it or by adding even more code for handling the new edge cases.

I wanted to strip things down, and see if I could start from a more stable foundations, and I turned to Vim conventions to do that. It was a natural choice because I was chasing that feeling from Vim. Choosing Vim also gave me the interaction bootstrapping effect that Zach is talking about. Rather than asking the user to start from interaction scratch, I had the Vim foundation. That's not directly relevant for the majority of people, Vim is only used a subset of programmers, so it doesn't solve everything, but it is a place to start.

Even for users not familiar with Vim conventions, I think there's a benefit to starting the experiments there, rather than trying to introduce a new paradigm. Vim has proven itself to at least be useful to many people (and inspired a lot of loyalty). So there's an implicit promise that even if this looks weird, you know it can be learned and at least some people have found it useful.

There's a whole series of [Vim-like programs](https://reversed.top/2016-08-13/big-list-of-vim-like-software/), mostly terminal-based, that use similar key combinations. There's also a number of browser extensions that let you [use Vim keybindings in the browser](https://vim.fandom.com/wiki/Vim_key_bindings_for_web_browsers). Tiling window managers (I use [i3wm](https://i3wm.org/)) also share a lot of conventions. Putting these all together, you can put together a system for daily use that is keyboard-focused and mostly Vim-based. I've started referring to the Constraint Systems experiments as "alternative" interfaces. Vimlike interfaces are arguably the longest running, most fully fleshed out alternative interface for computers. I want to add to and learn from that system, and keep it alive in the face of the conventions (often imported from mobile/touchscreen design) that are dominating today.
